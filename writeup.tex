\documentclass[11pt]{article}
\usepackage{common}
\title{CS 182 Final Project: Flaippy Bird}
\author{Joseph Kahn, Caetano Hanta-Davis, and Aron Szanto}
\begin{document}
\maketitle{}


\section{Introduction}

% A description of the purpose, goals, and scope of your system or
% empirical investigation.  You should include references to papers you
% read on which your project and any algorithms you used are
% based. Include a discussion of whether you adapted a published
% algorithm or devised a new one, the range of problems and issues you
% addressed, and the relation of these problems and issues to the
% techniques and ideas covered in the course.

This project was a technical study of the game ``Flappy Bird'' (FB) through the lens
of artificial intelligence. Using both deterministic and randomized paths,
we represented FB as both an informed search problem and a Q-Learning process.
Adopting the obvious end of maximizing the game's score as our agent's learning goal,
we approached this problem in three phases. First, we adapted an open source version
of this project into an interface conducive to AI work, redefining the game to be
comprised of familiar objects like states, goals, rewards, successors, and the other
necessary underlying factors. Second, we devised an informed search solution to the problem.
This involved requring the agent to solve a game with deterministic pipes, i.e.,
to figure out an action set that guides the agent through each pipe successfully.
We used the A* algorithm in this phase, with carefully designed heuristic that
served to break the larger problem into subproblems, with the agent only needing
to find a path between one pair of pipes at a time. The final phase of the project
was to relax the constraint of determinism in the pipes and to require the agent
to solve a game ``as it comes''. This involved a shift in paradigm, reforming
the game as an offline policy learning problem rather than as a search problem.
Our results were uniformly positive, with the AI-representation of the game serving
us well, the informed search algorithms able to solve large generated games in
quasilinear time, and the policy derived from Q-learning successful outperforming
any reasonable human.\\\\
This project was a true capstone to our study in this course. From proofs of
heuristic admissibility in informed search to extensive optimization of the policy
derivation algorithm in the Q-learning section, we engaged deeply with the core
tenets of the course throughout our work.


\section{Background and Related Work}



\section{Problem Specification}

% A clear description of the problem you are solving in both general terms
% and how you've mapped it to a formal problem specification.
We will first present an overview of our system's representation of the FB
environment, before specifying the problem formally for both informed search
and Q-Learning.\\\\
\subsection{Parameters of the Flappy Bird World}
The FB world is fully specified by the following:
\begin{enumerate}
    \item The location (in pixel coordinates) of the bird
    \item The locations of the pipes that the bird (or human player) can see
    \item The velocity and acceleration vectors of the bird
    \item The current score of the bird
    \item \emph{(If deterministic)} The offset in the pipe list that is next going to be generated
\end{enumerate}
\subsection{Informed Search}
In general terms, informed search is applied to FB by representing the FB
world as a sequence of nodes, each with a full specification of the world's state,
as outlined above. We define a goal test to ask whether a node's current score
is equal to the score desired (i.e., the size of the game currently being solved).
We also define a function to return the successors of a given node. Combined with
functionality to simulate the game's progress through time given the physical
attributes of each state, the FB world is represented well as an informed
search problem. Formally, the game is comprised of:
\\\\State nodes, each with:
\begin{enumerate}
    \item A location $x \in \reals^2$
    \item A velocity $v \in \reals^2$
    \item An acceleration $a \in \reals^2$
    \item A score $c \in \integers$
    \item A set of pipe locations $P \in (\reals^2)^n$, where $n$ is the
    number of pipes the bird can see
\end{enumerate}
The functions, each operating on a node $s$, with attributes subscripted as above
\begin{enumerate}
    \item $G(s) = \mathbb{1}(s_c = C)$, a goal test that returns true if and only if
    a node's score is equal to the goal score $C$.
    \item $A(s)$, a function returning the actions available to the agent at a state
    \item $N(s)$, a function that returns a set of neighbors of the node, along
    with the action required to get to each.
    \item $D(s)$, a function returning true if and only if the state represents the
    ``game over'' state (after a crash).
\end{enumerate}
The constants $C$, the ``goal number'' of nodes that codes the complexity of the
game, and various more mundane constants that denote the number of pixels on the screen
and such. It should be noted that for cleanliness, we abstracted these away into the
functions $G, D, A, N$ so that the agent doesn't ever need to interact with them.





\section{Approach}

A clear specification of the algorithm(s) you used and a description
of the main data structures in the implementation. Include a
discussion of any details of the algorithm that were not in the
published paper(s) that formed the basis of your implementation. A
reader should be able to reconstruct and verify your work from reading
your paper.

\begin{algorithm}
  \begin{algorithmic}
    \Procedure{MyAlgorithm}{$b$}
    \State{$a \gets 10$}
    \EndProcedure{}
  \end{algorithmic}
  \caption{Here is the algorithm.}
\end{algorithm}



\section{Experiments}
Analysis, evaluation, and critique of the algorithm and your
implementation. Include a description of the testing data you used and
a discussion of examples that illustrate major features of your
system. Testing is a critical part of system construction, and the
scope of your testing will be an important component in our
evaluation. Discuss what you learned from the implementation.

\begin{table}
  \centering
  \begin{tabular}{ll}
    \toprule
    & Score \\
    \midrule
    Approach 1 & \\
    Approach 2 & \\
    \bottomrule
  \end{tabular}
  \caption{Description of the results.}
\end{table}


\subsection{Results}

 For algorithm-comparison projects: a section reporting empirical comparison results preferably presented graphically.


\section{Discussion}

Summary of approach and results. Major takeaways? Things you could improve in future work?

\appendix

\section{System Description}

 Appendix 1 – A clear description of how to use your system and how to generate the output you discussed in the write-up. \emph{The teaching staff must be able to run your system.}

\section{Group Makeup}

 Appendix 2 – A list of each project participant and that
participant’s contributions to the project. If the division of work
varies significantly from the project proposal, provide a brief
explanation.  Your code should be clearly documented.



\bibliographystyle{plain}
\bibliography{project-template}

\end{document}
